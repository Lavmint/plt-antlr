//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 /data/cloud/Git/PLT/Analyzer/ANTLR/art.g 2015-12-05 01:01:43

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;

using Antlr.Runtime.Debug;
using IOException = System.IO.IOException;

using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
[System.CLSCompliant(false)]
public partial class artParser : DebugAntlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "AND", "ASSIGN", "BEGIN", "BLOCK", "BOOLEAN", "COLON", "COMMA", "COMMENT", "DO", "DOT", "ELSE", "END", "EQUAL", "EXPONENT", "FALSE", "FOR", "GE", "GT", "IDENT", "IDLIST", "IF", "INTEGER", "LCURLY", "LE", "LPAREN", "LT", "MINUS", "NOT", "NOT_EQUAL", "NUMLIST", "NUM_BIN", "NUM_DEC", "NUM_HEX", "NUM_OCT", "NUM_REAL", "OR", "PLUS", "PROGRAM", "RCURLY", "READ", "REAL", "RPAREN", "SEMI", "SLASH", "STAR", "THEN", "TO", "TRUE", "VAR", "VARDECL", "WHILE", "WRITE", "WS"
	};
	public const int EOF=-1;
	public const int AND=4;
	public const int ASSIGN=5;
	public const int BEGIN=6;
	public const int BLOCK=7;
	public const int BOOLEAN=8;
	public const int COLON=9;
	public const int COMMA=10;
	public const int COMMENT=11;
	public const int DO=12;
	public const int DOT=13;
	public const int ELSE=14;
	public const int END=15;
	public const int EQUAL=16;
	public const int EXPONENT=17;
	public const int FALSE=18;
	public const int FOR=19;
	public const int GE=20;
	public const int GT=21;
	public const int IDENT=22;
	public const int IDLIST=23;
	public const int IF=24;
	public const int INTEGER=25;
	public const int LCURLY=26;
	public const int LE=27;
	public const int LPAREN=28;
	public const int LT=29;
	public const int MINUS=30;
	public const int NOT=31;
	public const int NOT_EQUAL=32;
	public const int NUMLIST=33;
	public const int NUM_BIN=34;
	public const int NUM_DEC=35;
	public const int NUM_HEX=36;
	public const int NUM_OCT=37;
	public const int NUM_REAL=38;
	public const int OR=39;
	public const int PLUS=40;
	public const int PROGRAM=41;
	public const int RCURLY=42;
	public const int READ=43;
	public const int REAL=44;
	public const int RPAREN=45;
	public const int SEMI=46;
	public const int SLASH=47;
	public const int STAR=48;
	public const int THEN=49;
	public const int TO=50;
	public const int TRUE=51;
	public const int VAR=52;
	public const int VARDECL=53;
	public const int WHILE=54;
	public const int WRITE=55;
	public const int WS=56;

	public static readonly string[] ruleNames =
		new string[]
		{
			"invalidRule", "type", "num", "parameterList", "num_hex", "operators", 
		"logical", "identifier", "operator", "writeStatement", "term", "num_real", 
		"num_bin", "identifierList", "num_oct", "conditionalStatement", "operand", 
		"compoundStatement", "whileStatement", "emptyStatement", "assignmentStatement", 
		"readStatement", "num_dec", "variableDeclarationPart", "ifStatement", 
		"program", "expression", "variableDeclaration", "factor", "empty", "forStatement"
		};

		int ruleLevel = 0;
		public virtual int RuleLevel { get { return ruleLevel; } }
		public virtual void IncRuleLevel() { ruleLevel++; }
		public virtual void DecRuleLevel() { ruleLevel--; }
		public artParser( ITokenStream input )
			: this( input, DebugEventSocketProxy.DefaultDebuggerPort, new RecognizerSharedState() )
		{
		}
		public artParser( ITokenStream input, int port, RecognizerSharedState state )
			: base( input, state )
		{
			ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
			CreateTreeAdaptor(ref treeAdaptor);
			TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
			DebugEventSocketProxy proxy = new DebugEventSocketProxy( this, port, adaptor );
			DebugListener = proxy;
			ITokenStream = new DebugITokenStream( input, proxy );
			try
			{
				proxy.Handshake();
			}
			catch ( IOException ioe )
			{
				ReportError( ioe );
			}
			ITreeAdaptor adap = new CommonTreeAdaptor();
			TreeAdaptor = adap;
			proxy.TreeAdaptor = adap;
		}

	public artParser( ITokenStream input, IDebugEventListener dbg )
		: base( input, dbg )
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		ITreeAdaptor adap = new CommonTreeAdaptor();
		TreeAdaptor = adap;


	}

	protected virtual bool EvalPredicate( bool result, string predicate )
	{
		dbg.SemanticPredicate( result, predicate );
		return result;
	}

	// Implement this function in your helper file to use a custom tree adaptor
	partial void InitializeTreeAdaptor();
	protected DebugTreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}
		set
		{
			this.adaptor = new DebugTreeAdaptor(dbg,adaptor);


		}
	}


	public override string[] TokenNames { get { return artParser.tokenNames; } }
	public override string GrammarFileName { get { return "/data/cloud/Git/PLT/Analyzer/ANTLR/art.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_num_bin();
	partial void LeaveRule_num_bin();

	// $ANTLR start "num_bin"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:73:1: num_bin : NUM_BIN -> ^( NUMLIST ( num_bin )+ ) ;
	[GrammarRule("num_bin")]
	private AstParserRuleReturnScope<object, IToken> num_bin()
	{
		EnterRule_num_bin();
		EnterRule("num_bin", 1);
		TraceIn("num_bin", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUM_BIN1 = default(IToken);

		object NUM_BIN1_tree = default(object);
		RewriteRuleITokenStream stream_NUM_BIN=new RewriteRuleITokenStream(adaptor,"token NUM_BIN");
		try { DebugEnterRule(GrammarFileName, "num_bin");
		DebugLocation(73, 40);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:73:9: ( NUM_BIN -> ^( NUMLIST ( num_bin )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:73:11: NUM_BIN
			{
			DebugLocation(73, 11);
			NUM_BIN1=(IToken)Match(input,NUM_BIN,Follow._NUM_BIN_in_num_bin1379);  
			stream_NUM_BIN.Add(NUM_BIN1);



			{
			// AST REWRITE
			// elements: num_bin
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 73:19: -> ^( NUMLIST ( num_bin )+ )
			{
				DebugLocation(73, 22);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:73:22: ^( NUMLIST ( num_bin )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(73, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NUMLIST, "NUMLIST"), root_1);

				DebugLocation(73, 32);
				if (!(stream_num_bin.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_num_bin.HasNext )
				{
					DebugLocation(73, 32);

				}
				stream_num_bin.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_bin", 1);
			LeaveRule("num_bin", 1);
			LeaveRule_num_bin();
		}
		DebugLocation(73, 40);
		} finally { DebugExitRule(GrammarFileName, "num_bin"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num_bin"

	partial void EnterRule_num_oct();
	partial void LeaveRule_num_oct();

	// $ANTLR start "num_oct"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:74:1: num_oct : NUM_OCT -> ^( NUMLIST ( num_oct )+ ) ;
	[GrammarRule("num_oct")]
	private AstParserRuleReturnScope<object, IToken> num_oct()
	{
		EnterRule_num_oct();
		EnterRule("num_oct", 2);
		TraceIn("num_oct", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUM_OCT2 = default(IToken);

		object NUM_OCT2_tree = default(object);
		RewriteRuleITokenStream stream_NUM_OCT=new RewriteRuleITokenStream(adaptor,"token NUM_OCT");
		try { DebugEnterRule(GrammarFileName, "num_oct");
		DebugLocation(74, 40);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:74:9: ( NUM_OCT -> ^( NUMLIST ( num_oct )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:74:11: NUM_OCT
			{
			DebugLocation(74, 11);
			NUM_OCT2=(IToken)Match(input,NUM_OCT,Follow._NUM_OCT_in_num_oct1395);  
			stream_NUM_OCT.Add(NUM_OCT2);



			{
			// AST REWRITE
			// elements: num_oct
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 74:19: -> ^( NUMLIST ( num_oct )+ )
			{
				DebugLocation(74, 22);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:74:22: ^( NUMLIST ( num_oct )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(74, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NUMLIST, "NUMLIST"), root_1);

				DebugLocation(74, 32);
				if (!(stream_num_oct.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_num_oct.HasNext )
				{
					DebugLocation(74, 32);

				}
				stream_num_oct.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_oct", 2);
			LeaveRule("num_oct", 2);
			LeaveRule_num_oct();
		}
		DebugLocation(74, 40);
		} finally { DebugExitRule(GrammarFileName, "num_oct"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num_oct"

	partial void EnterRule_num_dec();
	partial void LeaveRule_num_dec();

	// $ANTLR start "num_dec"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:75:1: num_dec : NUM_DEC -> ^( NUMLIST ( num_dec )+ ) ;
	[GrammarRule("num_dec")]
	private AstParserRuleReturnScope<object, IToken> num_dec()
	{
		EnterRule_num_dec();
		EnterRule("num_dec", 3);
		TraceIn("num_dec", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUM_DEC3 = default(IToken);

		object NUM_DEC3_tree = default(object);
		RewriteRuleITokenStream stream_NUM_DEC=new RewriteRuleITokenStream(adaptor,"token NUM_DEC");
		try { DebugEnterRule(GrammarFileName, "num_dec");
		DebugLocation(75, 40);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:75:9: ( NUM_DEC -> ^( NUMLIST ( num_dec )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:75:11: NUM_DEC
			{
			DebugLocation(75, 11);
			NUM_DEC3=(IToken)Match(input,NUM_DEC,Follow._NUM_DEC_in_num_dec1411);  
			stream_NUM_DEC.Add(NUM_DEC3);



			{
			// AST REWRITE
			// elements: num_dec
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 75:19: -> ^( NUMLIST ( num_dec )+ )
			{
				DebugLocation(75, 22);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:75:22: ^( NUMLIST ( num_dec )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(75, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NUMLIST, "NUMLIST"), root_1);

				DebugLocation(75, 32);
				if (!(stream_num_dec.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_num_dec.HasNext )
				{
					DebugLocation(75, 32);

				}
				stream_num_dec.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_dec", 3);
			LeaveRule("num_dec", 3);
			LeaveRule_num_dec();
		}
		DebugLocation(75, 40);
		} finally { DebugExitRule(GrammarFileName, "num_dec"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num_dec"

	partial void EnterRule_num_hex();
	partial void LeaveRule_num_hex();

	// $ANTLR start "num_hex"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:76:1: num_hex : NUM_HEX -> ^( NUMLIST ( num_hex )+ ) ;
	[GrammarRule("num_hex")]
	private AstParserRuleReturnScope<object, IToken> num_hex()
	{
		EnterRule_num_hex();
		EnterRule("num_hex", 4);
		TraceIn("num_hex", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUM_HEX4 = default(IToken);

		object NUM_HEX4_tree = default(object);
		RewriteRuleITokenStream stream_NUM_HEX=new RewriteRuleITokenStream(adaptor,"token NUM_HEX");
		try { DebugEnterRule(GrammarFileName, "num_hex");
		DebugLocation(76, 40);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:76:9: ( NUM_HEX -> ^( NUMLIST ( num_hex )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:76:11: NUM_HEX
			{
			DebugLocation(76, 11);
			NUM_HEX4=(IToken)Match(input,NUM_HEX,Follow._NUM_HEX_in_num_hex1427);  
			stream_NUM_HEX.Add(NUM_HEX4);



			{
			// AST REWRITE
			// elements: num_hex
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 76:19: -> ^( NUMLIST ( num_hex )+ )
			{
				DebugLocation(76, 22);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:76:22: ^( NUMLIST ( num_hex )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(76, 24);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NUMLIST, "NUMLIST"), root_1);

				DebugLocation(76, 32);
				if (!(stream_num_hex.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_num_hex.HasNext )
				{
					DebugLocation(76, 32);

				}
				stream_num_hex.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_hex", 4);
			LeaveRule("num_hex", 4);
			LeaveRule_num_hex();
		}
		DebugLocation(76, 40);
		} finally { DebugExitRule(GrammarFileName, "num_hex"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num_hex"

	partial void EnterRule_num_real();
	partial void LeaveRule_num_real();

	// $ANTLR start "num_real"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:77:1: num_real : NUM_REAL -> ^( NUMLIST ( num_real )+ ) ;
	[GrammarRule("num_real")]
	private AstParserRuleReturnScope<object, IToken> num_real()
	{
		EnterRule_num_real();
		EnterRule("num_real", 5);
		TraceIn("num_real", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NUM_REAL5 = default(IToken);

		object NUM_REAL5_tree = default(object);
		RewriteRuleITokenStream stream_NUM_REAL=new RewriteRuleITokenStream(adaptor,"token NUM_REAL");
		try { DebugEnterRule(GrammarFileName, "num_real");
		DebugLocation(77, 42);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:77:9: ( NUM_REAL -> ^( NUMLIST ( num_real )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:77:11: NUM_REAL
			{
			DebugLocation(77, 11);
			NUM_REAL5=(IToken)Match(input,NUM_REAL,Follow._NUM_REAL_in_num_real1442);  
			stream_NUM_REAL.Add(NUM_REAL5);



			{
			// AST REWRITE
			// elements: num_real
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 77:20: -> ^( NUMLIST ( num_real )+ )
			{
				DebugLocation(77, 23);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:77:23: ^( NUMLIST ( num_real )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(77, 25);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(NUMLIST, "NUMLIST"), root_1);

				DebugLocation(77, 33);
				if (!(stream_num_real.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_num_real.HasNext )
				{
					DebugLocation(77, 33);

				}
				stream_num_real.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num_real", 5);
			LeaveRule("num_real", 5);
			LeaveRule_num_real();
		}
		DebugLocation(77, 42);
		} finally { DebugExitRule(GrammarFileName, "num_real"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num_real"

	partial void EnterRule_num();
	partial void LeaveRule_num();

	// $ANTLR start "num"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:1: num : ( num_bin | num_oct | num_dec | num_hex | num_real );
	[GrammarRule("num")]
	private AstParserRuleReturnScope<object, IToken> num()
	{
		EnterRule_num();
		EnterRule("num", 6);
		TraceIn("num", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> num_bin6 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> num_oct7 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> num_dec8 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> num_hex9 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> num_real10 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "num");
		DebugLocation(78, 46);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:5: ( num_bin | num_oct | num_dec | num_hex | num_real )
			int alt1=5;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case NUM_BIN:
				{
				alt1 = 1;
				}
				break;
			case NUM_OCT:
				{
				alt1 = 2;
				}
				break;
			case NUM_DEC:
				{
				alt1 = 3;
				}
				break;
			case NUM_HEX:
				{
				alt1 = 4;
				}
				break;
			case NUM_REAL:
				{
				alt1 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:7: num_bin
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 7);
				PushFollow(Follow._num_bin_in_num1458);
				num_bin6=num_bin();
				PopFollow();

				adaptor.AddChild(root_0, num_bin6.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:15: num_oct
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 15);
				PushFollow(Follow._num_oct_in_num1460);
				num_oct7=num_oct();
				PopFollow();

				adaptor.AddChild(root_0, num_oct7.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:23: num_dec
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 23);
				PushFollow(Follow._num_dec_in_num1462);
				num_dec8=num_dec();
				PopFollow();

				adaptor.AddChild(root_0, num_dec8.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:31: num_hex
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 31);
				PushFollow(Follow._num_hex_in_num1464);
				num_hex9=num_hex();
				PopFollow();

				adaptor.AddChild(root_0, num_hex9.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:78:39: num_real
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 39);
				PushFollow(Follow._num_real_in_num1466);
				num_real10=num_real();
				PopFollow();

				adaptor.AddChild(root_0, num_real10.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("num", 6);
			LeaveRule("num", 6);
			LeaveRule_num();
		}
		DebugLocation(78, 46);
		} finally { DebugExitRule(GrammarFileName, "num"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "num"

	partial void EnterRule_identifier();
	partial void LeaveRule_identifier();

	// $ANTLR start "identifier"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:80:1: identifier : IDENT ;
	[GrammarRule("identifier")]
	private AstParserRuleReturnScope<object, IToken> identifier()
	{
		EnterRule_identifier();
		EnterRule("identifier", 7);
		TraceIn("identifier", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDENT11 = default(IToken);

		object IDENT11_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "identifier");
		DebugLocation(80, 12);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:81:6: ( IDENT )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:81:8: IDENT
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(81, 8);
			IDENT11=(IToken)Match(input,IDENT,Follow._IDENT_in_identifier1481); 
			IDENT11_tree = (object)adaptor.Create(IDENT11);
			adaptor.AddChild(root_0, IDENT11_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifier", 7);
			LeaveRule("identifier", 7);
			LeaveRule_identifier();
		}
		DebugLocation(81, 12);
		} finally { DebugExitRule(GrammarFileName, "identifier"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "identifier"

	partial void EnterRule_logical();
	partial void LeaveRule_logical();

	// $ANTLR start "logical"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:82:1: logical : ( TRUE | FALSE );
	[GrammarRule("logical")]
	private AstParserRuleReturnScope<object, IToken> logical()
	{
		EnterRule_logical();
		EnterRule("logical", 8);
		TraceIn("logical", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set12 = default(IToken);

		object set12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "logical");
		DebugLocation(82, 20);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:82:9: ( TRUE | FALSE )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(82, 9);

			set12=(IToken)input.LT(1);
			if (input.LA(1)==FALSE||input.LA(1)==TRUE)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set12));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("logical", 8);
			LeaveRule("logical", 8);
			LeaveRule_logical();
		}
		DebugLocation(82, 20);
		} finally { DebugExitRule(GrammarFileName, "logical"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "logical"

	partial void EnterRule_type();
	partial void LeaveRule_type();

	// $ANTLR start "type"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:84:1: type : ( BOOLEAN | INTEGER | REAL );
	[GrammarRule("type")]
	private AstParserRuleReturnScope<object, IToken> type()
	{
		EnterRule_type();
		EnterRule("type", 9);
		TraceIn("type", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken set13 = default(IToken);

		object set13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "type");
		DebugLocation(84, 27);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:84:6: ( BOOLEAN | INTEGER | REAL )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(84, 6);

			set13=(IToken)input.LT(1);
			if (input.LA(1)==BOOLEAN||input.LA(1)==INTEGER||input.LA(1)==REAL)
			{
				input.Consume();
				adaptor.AddChild(root_0, (object)adaptor.Create(set13));
				state.errorRecovery=false;
			}
			else
			{
				MismatchedSetException mse = new MismatchedSetException(null,input);
				DebugRecognitionException(mse);
				throw mse;
			}


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("type", 9);
			LeaveRule("type", 9);
			LeaveRule_type();
		}
		DebugLocation(84, 27);
		} finally { DebugExitRule(GrammarFileName, "type"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "type"

	partial void EnterRule_expression();
	partial void LeaveRule_expression();

	// $ANTLR start "expression"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:87:1: expression : operand ( ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^) operand )* ;
	[GrammarRule("expression")]
	private AstParserRuleReturnScope<object, IToken> expression()
	{
		EnterRule_expression();
		EnterRule("expression", 10);
		TraceIn("expression", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUAL15 = default(IToken);
		IToken NOT_EQUAL16 = default(IToken);
		IToken LT17 = default(IToken);
		IToken LE18 = default(IToken);
		IToken GE19 = default(IToken);
		IToken GT20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> operand14 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operand21 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUAL15_tree = default(object);
		object NOT_EQUAL16_tree = default(object);
		object LT17_tree = default(object);
		object LE18_tree = default(object);
		object GE19_tree = default(object);
		object GT20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "expression");
		DebugLocation(87, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:5: ( operand ( ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^) operand )* )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:7: operand ( ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^) operand )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(88, 7);
			PushFollow(Follow._operand_in_expression1515);
			operand14=operand();
			PopFollow();

			adaptor.AddChild(root_0, operand14.Tree);
			DebugLocation(88, 15);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:15: ( ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^) operand )*
			try { DebugEnterSubRule(3);
			while (true)
			{
				int alt3=2;
				try { DebugEnterDecision(3, false);
				int LA3_0 = input.LA(1);

				if ((LA3_0==EQUAL||(LA3_0>=GE && LA3_0<=GT)||LA3_0==LE||LA3_0==LT||LA3_0==NOT_EQUAL))
				{
					alt3 = 1;
				}


				} finally { DebugExitDecision(3); }
				switch ( alt3 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:16: ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^) operand
					{
					DebugLocation(88, 16);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:16: ( EQUAL ^| NOT_EQUAL ^| LT ^| LE ^| GE ^| GT ^)
					int alt2=6;
					try { DebugEnterSubRule(2);
					try { DebugEnterDecision(2, false);
					switch (input.LA(1))
					{
					case EQUAL:
						{
						alt2 = 1;
						}
						break;
					case NOT_EQUAL:
						{
						alt2 = 2;
						}
						break;
					case LT:
						{
						alt2 = 3;
						}
						break;
					case LE:
						{
						alt2 = 4;
						}
						break;
					case GE:
						{
						alt2 = 5;
						}
						break;
					case GT:
						{
						alt2 = 6;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(2); }
					switch (alt2)
					{
					case 1:
						DebugEnterAlt(1);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:17: EQUAL ^
						{
						DebugLocation(88, 22);
						EQUAL15=(IToken)Match(input,EQUAL,Follow._EQUAL_in_expression1519); 
						EQUAL15_tree = (object)adaptor.Create(EQUAL15);
						root_0 = (object)adaptor.BecomeRoot(EQUAL15_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:26: NOT_EQUAL ^
						{
						DebugLocation(88, 35);
						NOT_EQUAL16=(IToken)Match(input,NOT_EQUAL,Follow._NOT_EQUAL_in_expression1524); 
						NOT_EQUAL16_tree = (object)adaptor.Create(NOT_EQUAL16);
						root_0 = (object)adaptor.BecomeRoot(NOT_EQUAL16_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:39: LT ^
						{
						DebugLocation(88, 41);
						LT17=(IToken)Match(input,LT,Follow._LT_in_expression1529); 
						LT17_tree = (object)adaptor.Create(LT17);
						root_0 = (object)adaptor.BecomeRoot(LT17_tree, root_0);

						}
						break;
					case 4:
						DebugEnterAlt(4);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:45: LE ^
						{
						DebugLocation(88, 47);
						LE18=(IToken)Match(input,LE,Follow._LE_in_expression1534); 
						LE18_tree = (object)adaptor.Create(LE18);
						root_0 = (object)adaptor.BecomeRoot(LE18_tree, root_0);

						}
						break;
					case 5:
						DebugEnterAlt(5);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:51: GE ^
						{
						DebugLocation(88, 53);
						GE19=(IToken)Match(input,GE,Follow._GE_in_expression1539); 
						GE19_tree = (object)adaptor.Create(GE19);
						root_0 = (object)adaptor.BecomeRoot(GE19_tree, root_0);

						}
						break;
					case 6:
						DebugEnterAlt(6);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:88:57: GT ^
						{
						DebugLocation(88, 59);
						GT20=(IToken)Match(input,GT,Follow._GT_in_expression1544); 
						GT20_tree = (object)adaptor.Create(GT20);
						root_0 = (object)adaptor.BecomeRoot(GT20_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(2); }

					DebugLocation(88, 62);
					PushFollow(Follow._operand_in_expression1548);
					operand21=operand();
					PopFollow();

					adaptor.AddChild(root_0, operand21.Tree);

					}
					break;

				default:
					goto loop3;
				}
			}

			loop3:
				;

			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("expression", 10);
			LeaveRule("expression", 10);
			LeaveRule_expression();
		}
		DebugLocation(89, 4);
		} finally { DebugExitRule(GrammarFileName, "expression"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "expression"

	partial void EnterRule_operand();
	partial void LeaveRule_operand();

	// $ANTLR start "operand"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:91:1: operand : term ( ( PLUS ^| MINUS ^| OR ^) term )* ;
	[GrammarRule("operand")]
	private AstParserRuleReturnScope<object, IToken> operand()
	{
		EnterRule_operand();
		EnterRule("operand", 11);
		TraceIn("operand", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PLUS23 = default(IToken);
		IToken MINUS24 = default(IToken);
		IToken OR25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> term22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> term26 = default(AstParserRuleReturnScope<object, IToken>);

		object PLUS23_tree = default(object);
		object MINUS24_tree = default(object);
		object OR25_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "operand");
		DebugLocation(91, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:5: ( term ( ( PLUS ^| MINUS ^| OR ^) term )* )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:7: term ( ( PLUS ^| MINUS ^| OR ^) term )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(92, 7);
			PushFollow(Follow._term_in_operand1568);
			term22=term();
			PopFollow();

			adaptor.AddChild(root_0, term22.Tree);
			DebugLocation(92, 12);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:12: ( ( PLUS ^| MINUS ^| OR ^) term )*
			try { DebugEnterSubRule(5);
			while (true)
			{
				int alt5=2;
				try { DebugEnterDecision(5, false);
				int LA5_0 = input.LA(1);

				if ((LA5_0==MINUS||(LA5_0>=OR && LA5_0<=PLUS)))
				{
					alt5 = 1;
				}


				} finally { DebugExitDecision(5); }
				switch ( alt5 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:14: ( PLUS ^| MINUS ^| OR ^) term
					{
					DebugLocation(92, 14);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:14: ( PLUS ^| MINUS ^| OR ^)
					int alt4=3;
					try { DebugEnterSubRule(4);
					try { DebugEnterDecision(4, false);
					switch (input.LA(1))
					{
					case PLUS:
						{
						alt4 = 1;
						}
						break;
					case MINUS:
						{
						alt4 = 2;
						}
						break;
					case OR:
						{
						alt4 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 4, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(4); }
					switch (alt4)
					{
					case 1:
						DebugEnterAlt(1);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:15: PLUS ^
						{
						DebugLocation(92, 19);
						PLUS23=(IToken)Match(input,PLUS,Follow._PLUS_in_operand1573); 
						PLUS23_tree = (object)adaptor.Create(PLUS23);
						root_0 = (object)adaptor.BecomeRoot(PLUS23_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:23: MINUS ^
						{
						DebugLocation(92, 28);
						MINUS24=(IToken)Match(input,MINUS,Follow._MINUS_in_operand1578); 
						MINUS24_tree = (object)adaptor.Create(MINUS24);
						root_0 = (object)adaptor.BecomeRoot(MINUS24_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:92:32: OR ^
						{
						DebugLocation(92, 34);
						OR25=(IToken)Match(input,OR,Follow._OR_in_operand1583); 
						OR25_tree = (object)adaptor.Create(OR25);
						root_0 = (object)adaptor.BecomeRoot(OR25_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(4); }

					DebugLocation(92, 37);
					PushFollow(Follow._term_in_operand1587);
					term26=term();
					PopFollow();

					adaptor.AddChild(root_0, term26.Tree);

					}
					break;

				default:
					goto loop5;
				}
			}

			loop5:
				;

			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operand", 11);
			LeaveRule("operand", 11);
			LeaveRule_operand();
		}
		DebugLocation(93, 4);
		} finally { DebugExitRule(GrammarFileName, "operand"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "operand"

	partial void EnterRule_term();
	partial void LeaveRule_term();

	// $ANTLR start "term"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:95:1: term : factor ( ( STAR ^| SLASH ^| AND ^) factor )* ;
	[GrammarRule("term")]
	private AstParserRuleReturnScope<object, IToken> term()
	{
		EnterRule_term();
		EnterRule("term", 12);
		TraceIn("term", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken STAR28 = default(IToken);
		IToken SLASH29 = default(IToken);
		IToken AND30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> factor27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> factor31 = default(AstParserRuleReturnScope<object, IToken>);

		object STAR28_tree = default(object);
		object SLASH29_tree = default(object);
		object AND30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "term");
		DebugLocation(95, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:3: ( factor ( ( STAR ^| SLASH ^| AND ^) factor )* )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:5: factor ( ( STAR ^| SLASH ^| AND ^) factor )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(96, 5);
			PushFollow(Follow._factor_in_term1605);
			factor27=factor();
			PopFollow();

			adaptor.AddChild(root_0, factor27.Tree);
			DebugLocation(96, 12);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:12: ( ( STAR ^| SLASH ^| AND ^) factor )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				int LA7_0 = input.LA(1);

				if ((LA7_0==AND||(LA7_0>=SLASH && LA7_0<=STAR)))
				{
					alt7 = 1;
				}


				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:14: ( STAR ^| SLASH ^| AND ^) factor
					{
					DebugLocation(96, 14);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:14: ( STAR ^| SLASH ^| AND ^)
					int alt6=3;
					try { DebugEnterSubRule(6);
					try { DebugEnterDecision(6, false);
					switch (input.LA(1))
					{
					case STAR:
						{
						alt6 = 1;
						}
						break;
					case SLASH:
						{
						alt6 = 2;
						}
						break;
					case AND:
						{
						alt6 = 3;
						}
						break;
					default:
						{
							NoViableAltException nvae = new NoViableAltException("", 6, 0, input);
							DebugRecognitionException(nvae);
							throw nvae;
						}
					}

					} finally { DebugExitDecision(6); }
					switch (alt6)
					{
					case 1:
						DebugEnterAlt(1);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:15: STAR ^
						{
						DebugLocation(96, 19);
						STAR28=(IToken)Match(input,STAR,Follow._STAR_in_term1610); 
						STAR28_tree = (object)adaptor.Create(STAR28);
						root_0 = (object)adaptor.BecomeRoot(STAR28_tree, root_0);

						}
						break;
					case 2:
						DebugEnterAlt(2);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:23: SLASH ^
						{
						DebugLocation(96, 28);
						SLASH29=(IToken)Match(input,SLASH,Follow._SLASH_in_term1615); 
						SLASH29_tree = (object)adaptor.Create(SLASH29);
						root_0 = (object)adaptor.BecomeRoot(SLASH29_tree, root_0);

						}
						break;
					case 3:
						DebugEnterAlt(3);
						// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:96:32: AND ^
						{
						DebugLocation(96, 35);
						AND30=(IToken)Match(input,AND,Follow._AND_in_term1620); 
						AND30_tree = (object)adaptor.Create(AND30);
						root_0 = (object)adaptor.BecomeRoot(AND30_tree, root_0);

						}
						break;

					}
					} finally { DebugExitSubRule(6); }

					DebugLocation(96, 38);
					PushFollow(Follow._factor_in_term1624);
					factor31=factor();
					PopFollow();

					adaptor.AddChild(root_0, factor31.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("term", 12);
			LeaveRule("term", 12);
			LeaveRule_term();
		}
		DebugLocation(97, 4);
		} finally { DebugExitRule(GrammarFileName, "term"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "term"

	partial void EnterRule_factor();
	partial void LeaveRule_factor();

	// $ANTLR start "factor"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:99:1: factor : ( identifier | num | logical | LPAREN ! expression RPAREN !| NOT ^ factor );
	[GrammarRule("factor")]
	private AstParserRuleReturnScope<object, IToken> factor()
	{
		EnterRule_factor();
		EnterRule("factor", 13);
		TraceIn("factor", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LPAREN35 = default(IToken);
		IToken RPAREN37 = default(IToken);
		IToken NOT38 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier32 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> num33 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> logical34 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression36 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> factor39 = default(AstParserRuleReturnScope<object, IToken>);

		object LPAREN35_tree = default(object);
		object RPAREN37_tree = default(object);
		object NOT38_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "factor");
		DebugLocation(99, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:100:5: ( identifier | num | logical | LPAREN ! expression RPAREN !| NOT ^ factor )
			int alt8=5;
			try { DebugEnterDecision(8, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt8 = 1;
				}
				break;
			case NUM_BIN:
			case NUM_DEC:
			case NUM_HEX:
			case NUM_OCT:
			case NUM_REAL:
				{
				alt8 = 2;
				}
				break;
			case FALSE:
			case TRUE:
				{
				alt8 = 3;
				}
				break;
			case LPAREN:
				{
				alt8 = 4;
				}
				break;
			case NOT:
				{
				alt8 = 5;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:100:7: identifier
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(100, 7);
				PushFollow(Follow._identifier_in_factor1644);
				identifier32=identifier();
				PopFollow();

				adaptor.AddChild(root_0, identifier32.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:101:7: num
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(101, 7);
				PushFollow(Follow._num_in_factor1652);
				num33=num();
				PopFollow();

				adaptor.AddChild(root_0, num33.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:102:7: logical
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(102, 7);
				PushFollow(Follow._logical_in_factor1660);
				logical34=logical();
				PopFollow();

				adaptor.AddChild(root_0, logical34.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:103:7: LPAREN ! expression RPAREN !
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(103, 13);
				LPAREN35=(IToken)Match(input,LPAREN,Follow._LPAREN_in_factor1668); 
				DebugLocation(103, 15);
				PushFollow(Follow._expression_in_factor1671);
				expression36=expression();
				PopFollow();

				adaptor.AddChild(root_0, expression36.Tree);
				DebugLocation(103, 32);
				RPAREN37=(IToken)Match(input,RPAREN,Follow._RPAREN_in_factor1673); 

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:104:7: NOT ^ factor
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(104, 10);
				NOT38=(IToken)Match(input,NOT,Follow._NOT_in_factor1682); 
				NOT38_tree = (object)adaptor.Create(NOT38);
				root_0 = (object)adaptor.BecomeRoot(NOT38_tree, root_0);
				DebugLocation(104, 12);
				PushFollow(Follow._factor_in_factor1685);
				factor39=factor();
				PopFollow();

				adaptor.AddChild(root_0, factor39.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("factor", 13);
			LeaveRule("factor", 13);
			LeaveRule_factor();
		}
		DebugLocation(105, 4);
		} finally { DebugExitRule(GrammarFileName, "factor"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "factor"

	partial void EnterRule_empty();
	partial void LeaveRule_empty();

	// $ANTLR start "empty"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:109:1: empty :;
	[GrammarRule("empty")]
	private AstParserRuleReturnScope<object, IToken> empty()
	{
		EnterRule_empty();
		EnterRule("empty", 14);
		TraceIn("empty", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		try { DebugEnterRule(GrammarFileName, "empty");
		DebugLocation(109, 3);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:110:4: ()
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:111:4: 
			{
			root_0 = (object)adaptor.Nil();

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		finally
		{
			TraceOut("empty", 14);
			LeaveRule("empty", 14);
			LeaveRule_empty();
		}
		DebugLocation(111, 3);
		} finally { DebugExitRule(GrammarFileName, "empty"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "empty"

	partial void EnterRule_emptyStatement();
	partial void LeaveRule_emptyStatement();

	// $ANTLR start "emptyStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:113:1: emptyStatement :;
	[GrammarRule("emptyStatement")]
	private AstParserRuleReturnScope<object, IToken> emptyStatement()
	{
		EnterRule_emptyStatement();
		EnterRule("emptyStatement", 15);
		TraceIn("emptyStatement", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		try { DebugEnterRule(GrammarFileName, "emptyStatement");
		DebugLocation(113, 3);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:114:4: ()
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:115:4: 
			{
			root_0 = (object)adaptor.Nil();

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		finally
		{
			TraceOut("emptyStatement", 15);
			LeaveRule("emptyStatement", 15);
			LeaveRule_emptyStatement();
		}
		DebugLocation(115, 3);
		} finally { DebugExitRule(GrammarFileName, "emptyStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "emptyStatement"

	partial void EnterRule_parameterList();
	partial void LeaveRule_parameterList();

	// $ANTLR start "parameterList"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:117:1: parameterList : expression ( COMMA expression )* ;
	[GrammarRule("parameterList")]
	private AstParserRuleReturnScope<object, IToken> parameterList()
	{
		EnterRule_parameterList();
		EnterRule("parameterList", 16);
		TraceIn("parameterList", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA41 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression40 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression42 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA41_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "parameterList");
		DebugLocation(117, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:118:5: ( expression ( COMMA expression )* )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:118:7: expression ( COMMA expression )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(118, 7);
			PushFollow(Follow._expression_in_parameterList1731);
			expression40=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression40.Tree);
			DebugLocation(118, 18);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:118:18: ( COMMA expression )*
			try { DebugEnterSubRule(9);
			while (true)
			{
				int alt9=2;
				try { DebugEnterDecision(9, false);
				int LA9_0 = input.LA(1);

				if ((LA9_0==COMMA))
				{
					alt9 = 1;
				}


				} finally { DebugExitDecision(9); }
				switch ( alt9 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:118:20: COMMA expression
					{
					DebugLocation(118, 20);
					COMMA41=(IToken)Match(input,COMMA,Follow._COMMA_in_parameterList1735); 
					COMMA41_tree = (object)adaptor.Create(COMMA41);
					adaptor.AddChild(root_0, COMMA41_tree);
					DebugLocation(118, 26);
					PushFollow(Follow._expression_in_parameterList1737);
					expression42=expression();
					PopFollow();

					adaptor.AddChild(root_0, expression42.Tree);

					}
					break;

				default:
					goto loop9;
				}
			}

			loop9:
				;

			} finally { DebugExitSubRule(9); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parameterList", 16);
			LeaveRule("parameterList", 16);
			LeaveRule_parameterList();
		}
		DebugLocation(119, 4);
		} finally { DebugExitRule(GrammarFileName, "parameterList"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "parameterList"

	partial void EnterRule_writeStatement();
	partial void LeaveRule_writeStatement();

	// $ANTLR start "writeStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:121:1: writeStatement : WRITE ^ LPAREN expression RPAREN ;
	[GrammarRule("writeStatement")]
	private AstParserRuleReturnScope<object, IToken> writeStatement()
	{
		EnterRule_writeStatement();
		EnterRule("writeStatement", 17);
		TraceIn("writeStatement", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WRITE43 = default(IToken);
		IToken LPAREN44 = default(IToken);
		IToken RPAREN46 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression45 = default(AstParserRuleReturnScope<object, IToken>);

		object WRITE43_tree = default(object);
		object LPAREN44_tree = default(object);
		object RPAREN46_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "writeStatement");
		DebugLocation(121, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:122:2: ( WRITE ^ LPAREN expression RPAREN )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:122:4: WRITE ^ LPAREN expression RPAREN
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(122, 9);
			WRITE43=(IToken)Match(input,WRITE,Follow._WRITE_in_writeStatement1758); 
			WRITE43_tree = (object)adaptor.Create(WRITE43);
			root_0 = (object)adaptor.BecomeRoot(WRITE43_tree, root_0);
			DebugLocation(122, 11);
			LPAREN44=(IToken)Match(input,LPAREN,Follow._LPAREN_in_writeStatement1761); 
			LPAREN44_tree = (object)adaptor.Create(LPAREN44);
			adaptor.AddChild(root_0, LPAREN44_tree);
			DebugLocation(122, 18);
			PushFollow(Follow._expression_in_writeStatement1763);
			expression45=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression45.Tree);
			DebugLocation(122, 29);
			RPAREN46=(IToken)Match(input,RPAREN,Follow._RPAREN_in_writeStatement1765); 
			RPAREN46_tree = (object)adaptor.Create(RPAREN46);
			adaptor.AddChild(root_0, RPAREN46_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("writeStatement", 17);
			LeaveRule("writeStatement", 17);
			LeaveRule_writeStatement();
		}
		DebugLocation(123, 1);
		} finally { DebugExitRule(GrammarFileName, "writeStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "writeStatement"

	partial void EnterRule_readStatement();
	partial void LeaveRule_readStatement();

	// $ANTLR start "readStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:125:1: readStatement : READ ^ LPAREN parameterList RPAREN ;
	[GrammarRule("readStatement")]
	private AstParserRuleReturnScope<object, IToken> readStatement()
	{
		EnterRule_readStatement();
		EnterRule("readStatement", 18);
		TraceIn("readStatement", 18);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken READ47 = default(IToken);
		IToken LPAREN48 = default(IToken);
		IToken RPAREN50 = default(IToken);
		AstParserRuleReturnScope<object, IToken> parameterList49 = default(AstParserRuleReturnScope<object, IToken>);

		object READ47_tree = default(object);
		object LPAREN48_tree = default(object);
		object RPAREN50_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "readStatement");
		DebugLocation(125, 1);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:126:2: ( READ ^ LPAREN parameterList RPAREN )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:126:4: READ ^ LPAREN parameterList RPAREN
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(126, 8);
			READ47=(IToken)Match(input,READ,Follow._READ_in_readStatement1777); 
			READ47_tree = (object)adaptor.Create(READ47);
			root_0 = (object)adaptor.BecomeRoot(READ47_tree, root_0);
			DebugLocation(126, 10);
			LPAREN48=(IToken)Match(input,LPAREN,Follow._LPAREN_in_readStatement1780); 
			LPAREN48_tree = (object)adaptor.Create(LPAREN48);
			adaptor.AddChild(root_0, LPAREN48_tree);
			DebugLocation(126, 17);
			PushFollow(Follow._parameterList_in_readStatement1782);
			parameterList49=parameterList();
			PopFollow();

			adaptor.AddChild(root_0, parameterList49.Tree);
			DebugLocation(126, 31);
			RPAREN50=(IToken)Match(input,RPAREN,Follow._RPAREN_in_readStatement1784); 
			RPAREN50_tree = (object)adaptor.Create(RPAREN50);
			adaptor.AddChild(root_0, RPAREN50_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("readStatement", 18);
			LeaveRule("readStatement", 18);
			LeaveRule_readStatement();
		}
		DebugLocation(127, 1);
		} finally { DebugExitRule(GrammarFileName, "readStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "readStatement"

	partial void EnterRule_assignmentStatement();
	partial void LeaveRule_assignmentStatement();

	// $ANTLR start "assignmentStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:129:1: assignmentStatement : identifier ASSIGN ^ expression ;
	[GrammarRule("assignmentStatement")]
	private AstParserRuleReturnScope<object, IToken> assignmentStatement()
	{
		EnterRule_assignmentStatement();
		EnterRule("assignmentStatement", 19);
		TraceIn("assignmentStatement", 19);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ASSIGN52 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier51 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression53 = default(AstParserRuleReturnScope<object, IToken>);

		object ASSIGN52_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "assignmentStatement");
		DebugLocation(129, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:130:5: ( identifier ASSIGN ^ expression )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:130:7: identifier ASSIGN ^ expression
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(130, 7);
			PushFollow(Follow._identifier_in_assignmentStatement1804);
			identifier51=identifier();
			PopFollow();

			adaptor.AddChild(root_0, identifier51.Tree);
			DebugLocation(130, 24);
			ASSIGN52=(IToken)Match(input,ASSIGN,Follow._ASSIGN_in_assignmentStatement1806); 
			ASSIGN52_tree = (object)adaptor.Create(ASSIGN52);
			root_0 = (object)adaptor.BecomeRoot(ASSIGN52_tree, root_0);
			DebugLocation(130, 26);
			PushFollow(Follow._expression_in_assignmentStatement1809);
			expression53=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression53.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("assignmentStatement", 19);
			LeaveRule("assignmentStatement", 19);
			LeaveRule_assignmentStatement();
		}
		DebugLocation(131, 4);
		} finally { DebugExitRule(GrammarFileName, "assignmentStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "assignmentStatement"

	partial void EnterRule_conditionalStatement();
	partial void LeaveRule_conditionalStatement();

	// $ANTLR start "conditionalStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:133:1: conditionalStatement : ifStatement ;
	[GrammarRule("conditionalStatement")]
	private AstParserRuleReturnScope<object, IToken> conditionalStatement()
	{
		EnterRule_conditionalStatement();
		EnterRule("conditionalStatement", 20);
		TraceIn("conditionalStatement", 20);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> ifStatement54 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "conditionalStatement");
		DebugLocation(133, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:134:5: ( ifStatement )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:134:7: ifStatement
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(134, 7);
			PushFollow(Follow._ifStatement_in_conditionalStatement1830);
			ifStatement54=ifStatement();
			PopFollow();

			adaptor.AddChild(root_0, ifStatement54.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("conditionalStatement", 20);
			LeaveRule("conditionalStatement", 20);
			LeaveRule_conditionalStatement();
		}
		DebugLocation(135, 4);
		} finally { DebugExitRule(GrammarFileName, "conditionalStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "conditionalStatement"

	partial void EnterRule_compoundStatement();
	partial void LeaveRule_compoundStatement();

	// $ANTLR start "compoundStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:137:1: compoundStatement : BEGIN operators END -> ^( BLOCK ( operators )* ) ;
	[GrammarRule("compoundStatement")]
	private AstParserRuleReturnScope<object, IToken> compoundStatement()
	{
		EnterRule_compoundStatement();
		EnterRule("compoundStatement", 21);
		TraceIn("compoundStatement", 21);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BEGIN55 = default(IToken);
		IToken END57 = default(IToken);
		AstParserRuleReturnScope<object, IToken> operators56 = default(AstParserRuleReturnScope<object, IToken>);

		object BEGIN55_tree = default(object);
		object END57_tree = default(object);
		RewriteRuleITokenStream stream_END=new RewriteRuleITokenStream(adaptor,"token END");
		RewriteRuleITokenStream stream_BEGIN=new RewriteRuleITokenStream(adaptor,"token BEGIN");
		RewriteRuleSubtreeStream stream_operators=new RewriteRuleSubtreeStream(adaptor,"rule operators");
		try { DebugEnterRule(GrammarFileName, "compoundStatement");
		DebugLocation(137, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:138:5: ( BEGIN operators END -> ^( BLOCK ( operators )* ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:138:7: BEGIN operators END
			{
			DebugLocation(138, 7);
			BEGIN55=(IToken)Match(input,BEGIN,Follow._BEGIN_in_compoundStatement1847);  
			stream_BEGIN.Add(BEGIN55);

			DebugLocation(138, 13);
			PushFollow(Follow._operators_in_compoundStatement1849);
			operators56=operators();
			PopFollow();

			stream_operators.Add(operators56.Tree);
			DebugLocation(139, 7);
			END57=(IToken)Match(input,END,Follow._END_in_compoundStatement1857);  
			stream_END.Add(END57);



			{
			// AST REWRITE
			// elements: operators
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 139:11: -> ^( BLOCK ( operators )* )
			{
				DebugLocation(139, 14);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:139:14: ^( BLOCK ( operators )* )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(139, 16);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(BLOCK, "BLOCK"), root_1);

				DebugLocation(139, 22);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:139:22: ( operators )*
				while ( stream_operators.HasNext )
				{
					DebugLocation(139, 22);
					adaptor.AddChild(root_1, stream_operators.NextTree());

				}
				stream_operators.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("compoundStatement", 21);
			LeaveRule("compoundStatement", 21);
			LeaveRule_compoundStatement();
		}
		DebugLocation(140, 4);
		} finally { DebugExitRule(GrammarFileName, "compoundStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "compoundStatement"

	partial void EnterRule_ifStatement();
	partial void LeaveRule_ifStatement();

	// $ANTLR start "ifStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:142:1: ifStatement : IF ^ expression THEN ! operator ( ELSE ! operator )? ;
	[GrammarRule("ifStatement")]
	private AstParserRuleReturnScope<object, IToken> ifStatement()
	{
		EnterRule_ifStatement();
		EnterRule("ifStatement", 22);
		TraceIn("ifStatement", 22);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IF58 = default(IToken);
		IToken THEN60 = default(IToken);
		IToken ELSE62 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression59 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator61 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator63 = default(AstParserRuleReturnScope<object, IToken>);

		object IF58_tree = default(object);
		object THEN60_tree = default(object);
		object ELSE62_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "ifStatement");
		DebugLocation(142, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:143:5: ( IF ^ expression THEN ! operator ( ELSE ! operator )? )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:143:7: IF ^ expression THEN ! operator ( ELSE ! operator )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(143, 9);
			IF58=(IToken)Match(input,IF,Follow._IF_in_ifStatement1888); 
			IF58_tree = (object)adaptor.Create(IF58);
			root_0 = (object)adaptor.BecomeRoot(IF58_tree, root_0);
			DebugLocation(143, 11);
			PushFollow(Follow._expression_in_ifStatement1891);
			expression59=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression59.Tree);
			DebugLocation(143, 26);
			THEN60=(IToken)Match(input,THEN,Follow._THEN_in_ifStatement1893); 
			DebugLocation(143, 28);
			PushFollow(Follow._operator_in_ifStatement1896);
			operator61=@operator();
			PopFollow();

			adaptor.AddChild(root_0, operator61.Tree);
			DebugLocation(143, 37);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:143:37: ( ELSE ! operator )?
			int alt10=2;
			try { DebugEnterSubRule(10);
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==ELSE))
			{
				alt10 = 1;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:143:38: ELSE ! operator
				{
				DebugLocation(143, 42);
				ELSE62=(IToken)Match(input,ELSE,Follow._ELSE_in_ifStatement1899); 
				DebugLocation(143, 44);
				PushFollow(Follow._operator_in_ifStatement1902);
				operator63=@operator();
				PopFollow();

				adaptor.AddChild(root_0, operator63.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(10); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("ifStatement", 22);
			LeaveRule("ifStatement", 22);
			LeaveRule_ifStatement();
		}
		DebugLocation(144, 4);
		} finally { DebugExitRule(GrammarFileName, "ifStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "ifStatement"

	partial void EnterRule_whileStatement();
	partial void LeaveRule_whileStatement();

	// $ANTLR start "whileStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:146:1: whileStatement : WHILE ^ expression DO ! operator ;
	[GrammarRule("whileStatement")]
	private AstParserRuleReturnScope<object, IToken> whileStatement()
	{
		EnterRule_whileStatement();
		EnterRule("whileStatement", 23);
		TraceIn("whileStatement", 23);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken WHILE64 = default(IToken);
		IToken DO66 = default(IToken);
		AstParserRuleReturnScope<object, IToken> expression65 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator67 = default(AstParserRuleReturnScope<object, IToken>);

		object WHILE64_tree = default(object);
		object DO66_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "whileStatement");
		DebugLocation(146, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:147:5: ( WHILE ^ expression DO ! operator )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:147:7: WHILE ^ expression DO ! operator
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(147, 12);
			WHILE64=(IToken)Match(input,WHILE,Follow._WHILE_in_whileStatement1921); 
			WHILE64_tree = (object)adaptor.Create(WHILE64);
			root_0 = (object)adaptor.BecomeRoot(WHILE64_tree, root_0);
			DebugLocation(147, 14);
			PushFollow(Follow._expression_in_whileStatement1924);
			expression65=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression65.Tree);
			DebugLocation(147, 27);
			DO66=(IToken)Match(input,DO,Follow._DO_in_whileStatement1926); 
			DebugLocation(147, 29);
			PushFollow(Follow._operator_in_whileStatement1929);
			operator67=@operator();
			PopFollow();

			adaptor.AddChild(root_0, operator67.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("whileStatement", 23);
			LeaveRule("whileStatement", 23);
			LeaveRule_whileStatement();
		}
		DebugLocation(148, 4);
		} finally { DebugExitRule(GrammarFileName, "whileStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "whileStatement"

	partial void EnterRule_forStatement();
	partial void LeaveRule_forStatement();

	// $ANTLR start "forStatement"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:150:1: forStatement : FOR ^ assignmentStatement TO ^ expression DO ! operator ;
	[GrammarRule("forStatement")]
	private AstParserRuleReturnScope<object, IToken> forStatement()
	{
		EnterRule_forStatement();
		EnterRule("forStatement", 24);
		TraceIn("forStatement", 24);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken FOR68 = default(IToken);
		IToken TO70 = default(IToken);
		IToken DO72 = default(IToken);
		AstParserRuleReturnScope<object, IToken> assignmentStatement69 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> expression71 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator73 = default(AstParserRuleReturnScope<object, IToken>);

		object FOR68_tree = default(object);
		object TO70_tree = default(object);
		object DO72_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "forStatement");
		DebugLocation(150, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:151:5: ( FOR ^ assignmentStatement TO ^ expression DO ! operator )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:151:7: FOR ^ assignmentStatement TO ^ expression DO ! operator
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(151, 10);
			FOR68=(IToken)Match(input,FOR,Follow._FOR_in_forStatement1946); 
			FOR68_tree = (object)adaptor.Create(FOR68);
			root_0 = (object)adaptor.BecomeRoot(FOR68_tree, root_0);
			DebugLocation(151, 12);
			PushFollow(Follow._assignmentStatement_in_forStatement1949);
			assignmentStatement69=assignmentStatement();
			PopFollow();

			adaptor.AddChild(root_0, assignmentStatement69.Tree);
			DebugLocation(151, 34);
			TO70=(IToken)Match(input,TO,Follow._TO_in_forStatement1951); 
			TO70_tree = (object)adaptor.Create(TO70);
			root_0 = (object)adaptor.BecomeRoot(TO70_tree, root_0);
			DebugLocation(151, 36);
			PushFollow(Follow._expression_in_forStatement1954);
			expression71=expression();
			PopFollow();

			adaptor.AddChild(root_0, expression71.Tree);
			DebugLocation(151, 49);
			DO72=(IToken)Match(input,DO,Follow._DO_in_forStatement1956); 
			DebugLocation(151, 51);
			PushFollow(Follow._operator_in_forStatement1959);
			operator73=@operator();
			PopFollow();

			adaptor.AddChild(root_0, operator73.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("forStatement", 24);
			LeaveRule("forStatement", 24);
			LeaveRule_forStatement();
		}
		DebugLocation(152, 4);
		} finally { DebugExitRule(GrammarFileName, "forStatement"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "forStatement"

	partial void EnterRule_identifierList();
	partial void LeaveRule_identifierList();

	// $ANTLR start "identifierList"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:156:1: identifierList : identifier ( COMMA identifier )* -> ^( IDLIST ( identifier )+ ) ;
	[GrammarRule("identifierList")]
	private AstParserRuleReturnScope<object, IToken> identifierList()
	{
		EnterRule_identifierList();
		EnterRule("identifierList", 25);
		TraceIn("identifierList", 25);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COMMA75 = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifier74 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> identifier76 = default(AstParserRuleReturnScope<object, IToken>);

		object COMMA75_tree = default(object);
		RewriteRuleITokenStream stream_COMMA=new RewriteRuleITokenStream(adaptor,"token COMMA");
		RewriteRuleSubtreeStream stream_identifier=new RewriteRuleSubtreeStream(adaptor,"rule identifier");
		try { DebugEnterRule(GrammarFileName, "identifierList");
		DebugLocation(156, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:157:5: ( identifier ( COMMA identifier )* -> ^( IDLIST ( identifier )+ ) )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:157:7: identifier ( COMMA identifier )*
			{
			DebugLocation(157, 7);
			PushFollow(Follow._identifier_in_identifierList1980);
			identifier74=identifier();
			PopFollow();

			stream_identifier.Add(identifier74.Tree);
			DebugLocation(157, 18);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:157:18: ( COMMA identifier )*
			try { DebugEnterSubRule(11);
			while (true)
			{
				int alt11=2;
				try { DebugEnterDecision(11, false);
				int LA11_0 = input.LA(1);

				if ((LA11_0==COMMA))
				{
					alt11 = 1;
				}


				} finally { DebugExitDecision(11); }
				switch ( alt11 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:157:20: COMMA identifier
					{
					DebugLocation(157, 20);
					COMMA75=(IToken)Match(input,COMMA,Follow._COMMA_in_identifierList1984);  
					stream_COMMA.Add(COMMA75);

					DebugLocation(157, 26);
					PushFollow(Follow._identifier_in_identifierList1986);
					identifier76=identifier();
					PopFollow();

					stream_identifier.Add(identifier76.Tree);

					}
					break;

				default:
					goto loop11;
				}
			}

			loop11:
				;

			} finally { DebugExitSubRule(11); }



			{
			// AST REWRITE
			// elements: identifier
			// token labels: 
			// rule labels: retval
			// token list labels: 
			// rule list labels: 
			// wildcard labels: 
			retval.Tree = root_0;
			RewriteRuleSubtreeStream stream_retval=new RewriteRuleSubtreeStream(adaptor,"rule retval",retval!=null?retval.Tree:null);

			root_0 = (object)adaptor.Nil();
			// 158:5: -> ^( IDLIST ( identifier )+ )
			{
				DebugLocation(158, 7);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:158:7: ^( IDLIST ( identifier )+ )
				{
				object root_1 = (object)adaptor.Nil();
				DebugLocation(158, 9);
				root_1 = (object)adaptor.BecomeRoot((object)adaptor.Create(IDLIST, "IDLIST"), root_1);

				DebugLocation(158, 16);
				if (!(stream_identifier.HasNext))
				{
					throw new RewriteEarlyExitException();
				}
				while ( stream_identifier.HasNext )
				{
					DebugLocation(158, 16);
					adaptor.AddChild(root_1, stream_identifier.NextTree());

				}
				stream_identifier.Reset();

				adaptor.AddChild(root_0, root_1);
				}

			}

			retval.Tree = root_0;
			}

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("identifierList", 25);
			LeaveRule("identifierList", 25);
			LeaveRule_identifierList();
		}
		DebugLocation(159, 4);
		} finally { DebugExitRule(GrammarFileName, "identifierList"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "identifierList"

	partial void EnterRule_variableDeclaration();
	partial void LeaveRule_variableDeclaration();

	// $ANTLR start "variableDeclaration"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:161:1: variableDeclaration : identifierList c= COLON ^ type ;
	[GrammarRule("variableDeclaration")]
	private AstParserRuleReturnScope<object, IToken> variableDeclaration()
	{
		EnterRule_variableDeclaration();
		EnterRule("variableDeclaration", 26);
		TraceIn("variableDeclaration", 26);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken c = default(IToken);
		AstParserRuleReturnScope<object, IToken> identifierList77 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> type78 = default(AstParserRuleReturnScope<object, IToken>);

		object c_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclaration");
		DebugLocation(161, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:162:5: ( identifierList c= COLON ^ type )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:162:7: identifierList c= COLON ^ type
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(162, 7);
			PushFollow(Follow._identifierList_in_variableDeclaration2022);
			identifierList77=identifierList();
			PopFollow();

			adaptor.AddChild(root_0, identifierList77.Tree);
			DebugLocation(162, 23);
			c=(IToken)Match(input,COLON,Follow._COLON_in_variableDeclaration2026); 
			c_tree = (object)adaptor.Create(c);
			root_0 = (object)adaptor.BecomeRoot(c_tree, root_0);
			DebugLocation(162, 31);
			c.setType(VARDECL);
			DebugLocation(162, 54);
			PushFollow(Follow._type_in_variableDeclaration2031);
			type78=type();
			PopFollow();

			adaptor.AddChild(root_0, type78.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclaration", 26);
			LeaveRule("variableDeclaration", 26);
			LeaveRule_variableDeclaration();
		}
		DebugLocation(163, 4);
		} finally { DebugExitRule(GrammarFileName, "variableDeclaration"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "variableDeclaration"

	partial void EnterRule_variableDeclarationPart();
	partial void LeaveRule_variableDeclarationPart();

	// $ANTLR start "variableDeclarationPart"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:165:1: variableDeclarationPart : VAR ^ variableDeclaration ( SEMI ! variableDeclaration )* SEMI !;
	[GrammarRule("variableDeclarationPart")]
	private AstParserRuleReturnScope<object, IToken> variableDeclarationPart()
	{
		EnterRule_variableDeclarationPart();
		EnterRule("variableDeclarationPart", 27);
		TraceIn("variableDeclarationPart", 27);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken VAR79 = default(IToken);
		IToken SEMI81 = default(IToken);
		IToken SEMI83 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclaration80 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> variableDeclaration82 = default(AstParserRuleReturnScope<object, IToken>);

		object VAR79_tree = default(object);
		object SEMI81_tree = default(object);
		object SEMI83_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "variableDeclarationPart");
		DebugLocation(165, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:166:5: ( VAR ^ variableDeclaration ( SEMI ! variableDeclaration )* SEMI !)
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:166:7: VAR ^ variableDeclaration ( SEMI ! variableDeclaration )* SEMI !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(166, 10);
			VAR79=(IToken)Match(input,VAR,Follow._VAR_in_variableDeclarationPart2048); 
			VAR79_tree = (object)adaptor.Create(VAR79);
			root_0 = (object)adaptor.BecomeRoot(VAR79_tree, root_0);
			DebugLocation(166, 12);
			PushFollow(Follow._variableDeclaration_in_variableDeclarationPart2051);
			variableDeclaration80=variableDeclaration();
			PopFollow();

			adaptor.AddChild(root_0, variableDeclaration80.Tree);
			DebugLocation(166, 32);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:166:32: ( SEMI ! variableDeclaration )*
			try { DebugEnterSubRule(12);
			while (true)
			{
				int alt12=2;
				try { DebugEnterDecision(12, false);
				int LA12_0 = input.LA(1);

				if ((LA12_0==SEMI))
				{
					int LA12_1 = input.LA(2);

					if ((LA12_1==IDENT))
					{
						alt12 = 1;
					}


				}


				} finally { DebugExitDecision(12); }
				switch ( alt12 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:166:34: SEMI ! variableDeclaration
					{
					DebugLocation(166, 38);
					SEMI81=(IToken)Match(input,SEMI,Follow._SEMI_in_variableDeclarationPart2055); 
					DebugLocation(166, 40);
					PushFollow(Follow._variableDeclaration_in_variableDeclarationPart2058);
					variableDeclaration82=variableDeclaration();
					PopFollow();

					adaptor.AddChild(root_0, variableDeclaration82.Tree);

					}
					break;

				default:
					goto loop12;
				}
			}

			loop12:
				;

			} finally { DebugExitSubRule(12); }

			DebugLocation(166, 67);
			SEMI83=(IToken)Match(input,SEMI,Follow._SEMI_in_variableDeclarationPart2063); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("variableDeclarationPart", 27);
			LeaveRule("variableDeclarationPart", 27);
			LeaveRule_variableDeclarationPart();
		}
		DebugLocation(167, 4);
		} finally { DebugExitRule(GrammarFileName, "variableDeclarationPart"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "variableDeclarationPart"

	partial void EnterRule_operator();
	partial void LeaveRule_operator();

	// $ANTLR start "operator"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:169:1: operator : ( assignmentStatement | writeStatement | readStatement | compoundStatement | conditionalStatement | whileStatement | forStatement | emptyStatement );
	[GrammarRule("operator")]
	private AstParserRuleReturnScope<object, IToken> @operator()
	{
		EnterRule_operator();
		EnterRule("operator", 28);
		TraceIn("operator", 28);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> assignmentStatement84 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> writeStatement85 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> readStatement86 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> compoundStatement87 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> conditionalStatement88 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> whileStatement89 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> forStatement90 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> emptyStatement91 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "operator");
		DebugLocation(169, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:170:5: ( assignmentStatement | writeStatement | readStatement | compoundStatement | conditionalStatement | whileStatement | forStatement | emptyStatement )
			int alt13=8;
			try { DebugEnterDecision(13, false);
			switch (input.LA(1))
			{
			case IDENT:
				{
				alt13 = 1;
				}
				break;
			case WRITE:
				{
				alt13 = 2;
				}
				break;
			case READ:
				{
				alt13 = 3;
				}
				break;
			case BEGIN:
				{
				alt13 = 4;
				}
				break;
			case IF:
				{
				alt13 = 5;
				}
				break;
			case WHILE:
				{
				alt13 = 6;
				}
				break;
			case FOR:
				{
				alt13 = 7;
				}
				break;
			case COLON:
			case ELSE:
			case END:
			case SEMI:
				{
				alt13 = 8;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 13, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(13); }
			switch (alt13)
			{
			case 1:
				DebugEnterAlt(1);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:170:7: assignmentStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(170, 7);
				PushFollow(Follow._assignmentStatement_in_operator2081);
				assignmentStatement84=assignmentStatement();
				PopFollow();

				adaptor.AddChild(root_0, assignmentStatement84.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:171:7: writeStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(171, 7);
				PushFollow(Follow._writeStatement_in_operator2089);
				writeStatement85=writeStatement();
				PopFollow();

				adaptor.AddChild(root_0, writeStatement85.Tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:172:7: readStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(172, 7);
				PushFollow(Follow._readStatement_in_operator2097);
				readStatement86=readStatement();
				PopFollow();

				adaptor.AddChild(root_0, readStatement86.Tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:173:7: compoundStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(173, 7);
				PushFollow(Follow._compoundStatement_in_operator2105);
				compoundStatement87=compoundStatement();
				PopFollow();

				adaptor.AddChild(root_0, compoundStatement87.Tree);

				}
				break;
			case 5:
				DebugEnterAlt(5);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:174:7: conditionalStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(174, 7);
				PushFollow(Follow._conditionalStatement_in_operator2113);
				conditionalStatement88=conditionalStatement();
				PopFollow();

				adaptor.AddChild(root_0, conditionalStatement88.Tree);

				}
				break;
			case 6:
				DebugEnterAlt(6);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:175:7: whileStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(175, 7);
				PushFollow(Follow._whileStatement_in_operator2121);
				whileStatement89=whileStatement();
				PopFollow();

				adaptor.AddChild(root_0, whileStatement89.Tree);

				}
				break;
			case 7:
				DebugEnterAlt(7);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:176:7: forStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(176, 7);
				PushFollow(Follow._forStatement_in_operator2129);
				forStatement90=forStatement();
				PopFollow();

				adaptor.AddChild(root_0, forStatement90.Tree);

				}
				break;
			case 8:
				DebugEnterAlt(8);
				// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:177:7: emptyStatement
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(177, 7);
				PushFollow(Follow._emptyStatement_in_operator2137);
				emptyStatement91=emptyStatement();
				PopFollow();

				adaptor.AddChild(root_0, emptyStatement91.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operator", 28);
			LeaveRule("operator", 28);
			LeaveRule_operator();
		}
		DebugLocation(178, 4);
		} finally { DebugExitRule(GrammarFileName, "operator"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "operator"

	partial void EnterRule_operators();
	partial void LeaveRule_operators();

	// $ANTLR start "operators"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:180:1: operators : operator ( COLON ! operator )* ;
	[GrammarRule("operators")]
	private AstParserRuleReturnScope<object, IToken> operators()
	{
		EnterRule_operators();
		EnterRule("operators", 29);
		TraceIn("operators", 29);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken COLON93 = default(IToken);
		AstParserRuleReturnScope<object, IToken> operator92 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator94 = default(AstParserRuleReturnScope<object, IToken>);

		object COLON93_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "operators");
		DebugLocation(180, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:181:5: ( operator ( COLON ! operator )* )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:181:7: operator ( COLON ! operator )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(181, 7);
			PushFollow(Follow._operator_in_operators2154);
			operator92=@operator();
			PopFollow();

			adaptor.AddChild(root_0, operator92.Tree);
			DebugLocation(181, 16);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:181:16: ( COLON ! operator )*
			try { DebugEnterSubRule(14);
			while (true)
			{
				int alt14=2;
				try { DebugEnterDecision(14, false);
				int LA14_0 = input.LA(1);

				if ((LA14_0==COLON))
				{
					alt14 = 1;
				}


				} finally { DebugExitDecision(14); }
				switch ( alt14 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:181:18: COLON ! operator
					{
					DebugLocation(181, 23);
					COLON93=(IToken)Match(input,COLON,Follow._COLON_in_operators2158); 
					DebugLocation(181, 25);
					PushFollow(Follow._operator_in_operators2161);
					operator94=@operator();
					PopFollow();

					adaptor.AddChild(root_0, operator94.Tree);

					}
					break;

				default:
					goto loop14;
				}
			}

			loop14:
				;

			} finally { DebugExitSubRule(14); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("operators", 29);
			LeaveRule("operators", 29);
			LeaveRule_operators();
		}
		DebugLocation(182, 4);
		} finally { DebugExitRule(GrammarFileName, "operators"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "operators"

	partial void EnterRule_program();
	partial void LeaveRule_program();

	// $ANTLR start "program"
	// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:184:1: program : PROGRAM ^ ( variableDeclarationPart )* BEGIN ^ operator ( SEMI ! operator )* END DOT ;
	[GrammarRule("program")]
	private AstParserRuleReturnScope<object, IToken> program()
	{
		EnterRule_program();
		EnterRule("program", 30);
		TraceIn("program", 30);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken PROGRAM95 = default(IToken);
		IToken BEGIN97 = default(IToken);
		IToken SEMI99 = default(IToken);
		IToken END101 = default(IToken);
		IToken DOT102 = default(IToken);
		AstParserRuleReturnScope<object, IToken> variableDeclarationPart96 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator98 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> operator100 = default(AstParserRuleReturnScope<object, IToken>);

		object PROGRAM95_tree = default(object);
		object BEGIN97_tree = default(object);
		object SEMI99_tree = default(object);
		object END101_tree = default(object);
		object DOT102_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "program");
		DebugLocation(184, 4);
		if (RuleLevel == 0)
			DebugListener.Commence();
		IncRuleLevel();
		try
		{
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:5: ( PROGRAM ^ ( variableDeclarationPart )* BEGIN ^ operator ( SEMI ! operator )* END DOT )
			DebugEnterAlt(1);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:7: PROGRAM ^ ( variableDeclarationPart )* BEGIN ^ operator ( SEMI ! operator )* END DOT
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(185, 14);
			PROGRAM95=(IToken)Match(input,PROGRAM,Follow._PROGRAM_in_program2186); 
			PROGRAM95_tree = (object)adaptor.Create(PROGRAM95);
			root_0 = (object)adaptor.BecomeRoot(PROGRAM95_tree, root_0);
			DebugLocation(185, 16);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:16: ( variableDeclarationPart )*
			try { DebugEnterSubRule(15);
			while (true)
			{
				int alt15=2;
				try { DebugEnterDecision(15, false);
				int LA15_0 = input.LA(1);

				if ((LA15_0==VAR))
				{
					alt15 = 1;
				}


				} finally { DebugExitDecision(15); }
				switch ( alt15 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:18: variableDeclarationPart
					{
					DebugLocation(185, 18);
					PushFollow(Follow._variableDeclarationPart_in_program2191);
					variableDeclarationPart96=variableDeclarationPart();
					PopFollow();

					adaptor.AddChild(root_0, variableDeclarationPart96.Tree);

					}
					break;

				default:
					goto loop15;
				}
			}

			loop15:
				;

			} finally { DebugExitSubRule(15); }

			DebugLocation(185, 49);
			BEGIN97=(IToken)Match(input,BEGIN,Follow._BEGIN_in_program2195); 
			BEGIN97_tree = (object)adaptor.Create(BEGIN97);
			root_0 = (object)adaptor.BecomeRoot(BEGIN97_tree, root_0);
			DebugLocation(185, 51);
			PushFollow(Follow._operator_in_program2198);
			operator98=@operator();
			PopFollow();

			adaptor.AddChild(root_0, operator98.Tree);
			DebugLocation(185, 60);
			// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:60: ( SEMI ! operator )*
			try { DebugEnterSubRule(16);
			while (true)
			{
				int alt16=2;
				try { DebugEnterDecision(16, false);
				int LA16_0 = input.LA(1);

				if ((LA16_0==SEMI))
				{
					alt16 = 1;
				}


				} finally { DebugExitDecision(16); }
				switch ( alt16 )
				{
				case 1:
					DebugEnterAlt(1);
					// /data/cloud/Git/PLT/Analyzer/ANTLR/art.g:185:62: SEMI ! operator
					{
					DebugLocation(185, 66);
					SEMI99=(IToken)Match(input,SEMI,Follow._SEMI_in_program2202); 
					DebugLocation(185, 68);
					PushFollow(Follow._operator_in_program2205);
					operator100=@operator();
					PopFollow();

					adaptor.AddChild(root_0, operator100.Tree);

					}
					break;

				default:
					goto loop16;
				}
			}

			loop16:
				;

			} finally { DebugExitSubRule(16); }

			DebugLocation(185, 80);
			END101=(IToken)Match(input,END,Follow._END_in_program2210); 
			END101_tree = (object)adaptor.Create(END101);
			adaptor.AddChild(root_0, END101_tree);
			DebugLocation(185, 84);
			DOT102=(IToken)Match(input,DOT,Follow._DOT_in_program2212); 
			DOT102_tree = (object)adaptor.Create(DOT102);
			adaptor.AddChild(root_0, DOT102_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("program", 30);
			LeaveRule("program", 30);
			LeaveRule_program();
		}
		DebugLocation(186, 4);
		} finally { DebugExitRule(GrammarFileName, "program"); }
		DecRuleLevel();
		if (RuleLevel == 0)
			DebugListener.Terminate();
		return retval;

	}
	// $ANTLR end "program"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _NUM_BIN_in_num_bin1379 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUM_OCT_in_num_oct1395 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUM_DEC_in_num_dec1411 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUM_HEX_in_num_hex1427 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NUM_REAL_in_num_real1442 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_bin_in_num1458 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_oct_in_num1460 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_dec_in_num1462 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_hex_in_num1464 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_real_in_num1466 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IDENT_in_identifier1481 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operand_in_expression1515 = new BitSet(new ulong[]{0x128310002UL});
		public static readonly BitSet _EQUAL_in_expression1519 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _NOT_EQUAL_in_expression1524 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _LT_in_expression1529 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _LE_in_expression1534 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _GE_in_expression1539 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _GT_in_expression1544 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _operand_in_expression1548 = new BitSet(new ulong[]{0x128310002UL});
		public static readonly BitSet _term_in_operand1568 = new BitSet(new ulong[]{0x18040000002UL});
		public static readonly BitSet _PLUS_in_operand1573 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _MINUS_in_operand1578 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _OR_in_operand1583 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _term_in_operand1587 = new BitSet(new ulong[]{0x18040000002UL});
		public static readonly BitSet _factor_in_term1605 = new BitSet(new ulong[]{0x1800000000012UL});
		public static readonly BitSet _STAR_in_term1610 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _SLASH_in_term1615 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _AND_in_term1620 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _factor_in_term1624 = new BitSet(new ulong[]{0x1800000000012UL});
		public static readonly BitSet _identifier_in_factor1644 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _num_in_factor1652 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _logical_in_factor1660 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LPAREN_in_factor1668 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_factor1671 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RPAREN_in_factor1673 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NOT_in_factor1682 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _factor_in_factor1685 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _expression_in_parameterList1731 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _COMMA_in_parameterList1735 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_parameterList1737 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _WRITE_in_writeStatement1758 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _LPAREN_in_writeStatement1761 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_writeStatement1763 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RPAREN_in_writeStatement1765 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _READ_in_readStatement1777 = new BitSet(new ulong[]{0x10000000UL});
		public static readonly BitSet _LPAREN_in_readStatement1780 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _parameterList_in_readStatement1782 = new BitSet(new ulong[]{0x200000000000UL});
		public static readonly BitSet _RPAREN_in_readStatement1784 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_assignmentStatement1804 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _ASSIGN_in_assignmentStatement1806 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_assignmentStatement1809 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ifStatement_in_conditionalStatement1830 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BEGIN_in_compoundStatement1847 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operators_in_compoundStatement1849 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _END_in_compoundStatement1857 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _IF_in_ifStatement1888 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_ifStatement1891 = new BitSet(new ulong[]{0x2000000000000UL});
		public static readonly BitSet _THEN_in_ifStatement1893 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_ifStatement1896 = new BitSet(new ulong[]{0x4002UL});
		public static readonly BitSet _ELSE_in_ifStatement1899 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_ifStatement1902 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _WHILE_in_whileStatement1921 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_whileStatement1924 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _DO_in_whileStatement1926 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_whileStatement1929 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _FOR_in_forStatement1946 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _assignmentStatement_in_forStatement1949 = new BitSet(new ulong[]{0x4000000000000UL});
		public static readonly BitSet _TO_in_forStatement1951 = new BitSet(new ulong[]{0x8007C90440000UL});
		public static readonly BitSet _expression_in_forStatement1954 = new BitSet(new ulong[]{0x1000UL});
		public static readonly BitSet _DO_in_forStatement1956 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_forStatement1959 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _identifier_in_identifierList1980 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _COMMA_in_identifierList1984 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _identifier_in_identifierList1986 = new BitSet(new ulong[]{0x402UL});
		public static readonly BitSet _identifierList_in_variableDeclaration2022 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _COLON_in_variableDeclaration2026 = new BitSet(new ulong[]{0x100002000100UL});
		public static readonly BitSet _type_in_variableDeclaration2031 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _VAR_in_variableDeclarationPart2048 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationPart2051 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_variableDeclarationPart2055 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _variableDeclaration_in_variableDeclarationPart2058 = new BitSet(new ulong[]{0x400000000000UL});
		public static readonly BitSet _SEMI_in_variableDeclarationPart2063 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _assignmentStatement_in_operator2081 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _writeStatement_in_operator2089 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _readStatement_in_operator2097 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _compoundStatement_in_operator2105 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _conditionalStatement_in_operator2113 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _whileStatement_in_operator2121 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _forStatement_in_operator2129 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _emptyStatement_in_operator2137 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _operator_in_operators2154 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _COLON_in_operators2158 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_operators2161 = new BitSet(new ulong[]{0x202UL});
		public static readonly BitSet _PROGRAM_in_program2186 = new BitSet(new ulong[]{0x10000000000040UL});
		public static readonly BitSet _variableDeclarationPart_in_program2191 = new BitSet(new ulong[]{0x10000000000040UL});
		public static readonly BitSet _BEGIN_in_program2195 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_program2198 = new BitSet(new ulong[]{0x400000008000UL});
		public static readonly BitSet _SEMI_in_program2202 = new BitSet(new ulong[]{0xC0080001480040UL});
		public static readonly BitSet _operator_in_program2205 = new BitSet(new ulong[]{0x400000008000UL});
		public static readonly BitSet _END_in_program2210 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _DOT_in_program2212 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
